<?php

namespace AwardWallet\Engine\sncf\Email;

use AwardWallet\Common\Parser\Util\PriceHelper;
use AwardWallet\Engine\MonthTranslate;
use AwardWallet\Schema\Parser\Email\Email;
use PlancakeEmailParser;

class ETicketPdf extends \TAccountChecker
{
    public $mailFiles = "sncf/it-12268762.eml, sncf/it-38000223.eml, sncf/it-38116223.eml, sncf/it-65262728.eml, sncf/it-8497860.eml, sncf/it-8586276.eml";

    public static $dictionary = [
        "fr" => [
            "europe"        => "L'Europe",
            "pageHeader"    => ["VOTRE MEMO E-BILLET", "VOTRE REÇU D'ACHAT", "VOTRE E-BILLET", "JUSTIFICATIF DE VOYAGE"],
            "cardNumber"    => ["N° de carte de fidélité Grand Voyageur Le Club", "Référence client", "Référence client"],
            "endSegment"    => ["Présence à quai", "Pour connaître", "Pour calculer", "CARTE AVANTAGE"],
            "Bonjour"       => "Bonjour",
        ],
        "en" => [
            "europe"           => "Europe",
            "pageHeader"       => ["YOUR E-TICKET", "YOUR E-TICKET CONFIRMATION", "RECEIPT"],
            "DOSSIER VOYAGE"   => ["BOOKING FILE REFERENCE", "REFERENCE NUMBER", 'DOSSIER REFERENCE'],
            "Nom"              => ["Surname", 'Lastname'],
            "Prénom"           => ["First Name", 'Firstname'],
            "N° e-billet"      => ["E-ticket number", "No. e-ticket"],
            "cardNumber"       => "Customer reference number",
            "Départ / Arrivée" => "Departure / Arrival",
            "endSegment"       => [
                "You must be aboard at", "Please arrive at", "To calculate the greenhouse gases generated by your journey",
            ],
            "Date / Heure" => "Date / Time",
            "TRAIN N°"     => ["TRAIN NUMBER", 'TRAIN NR'],
            "CLASSE"       => "CLASS",

            //            "Bonjour"       => "", // need tr
        ],
        "de" => [
            "europe"           => "Europa",
            "pageHeader"       => "IHR E-TICKET",
            "DOSSIER VOYAGE"   => ["REISEREFERENZ"],
            "Nom"              => "Name",
            "Prénom"           => "Vorname",
            "N° e-billet"      => ["Nr. E-Ticket"],
            "cardNumber"       => "Kundenreferenz",
            "Départ / Arrivée" => "Abfahrt / Ankunft",
            "endSegment"       => ["Erscheinen Sie bitte"],
            "Date / Heure"     => "Datum / Uhrzeit",
            "TRAIN N°"         => "ZUGNUMMER",
            "CLASSE"           => "KLASSE",
        ],
        "nl" => [
            "europe"           => "Europa",
            "pageHeader"       => "UW E-TICKET",
            "DOSSIER VOYAGE"   => ["BOEKINGSCODE"],
            "Nom"              => "Naam",
            "Prénom"           => "Voornaam",
            "N° e-billet"      => ["E-ticket nr."],
            "cardNumber"       => "Klant nr.",
            "Départ / Arrivée" => "Vertrek / Aankomst",
            "endSegment"       => ["Aanwezigheid verplicht 2 minuten voor vertrek"],
            "Date / Heure"     => "Datum / Uur",
            "TRAIN N°"         => "TREIN NR",
            "CLASSE"           => "klasse",
        ],
    ];

    public $lang = "fr";

    private $reFrom = "no-reply@voyages-sncf.com";

    private $reSubject = [
        "fr"=> "Confirmation d'échange de votre e-billet",
        "en"=> "Your e-ticket ",
    ];

    private $reBody = 'SNCF';

    private $reBody2 = [
        "fr" => "Départ / Arrivée",
        "en" => "Departure / Arrival",
        "de" => "Abfahrt / Ankunft",
        "nl" => "Vertrek / Aankomst",
    ];

    private $pdfPattern = ".*.pdf";

    private $date;

    public function detectEmailFromProvider($from)
    {
        return strpos($from, $this->reFrom) !== false;
    }

    public function detectEmailByHeaders(array $headers)
    {
        if (strpos($headers["from"], $this->reFrom) === false) {
            return false;
        }

        foreach ($this->reSubject as $re) {
            if (stripos($headers["subject"], $re) !== false) {
                return true;
            }
        }

        return false;
    }

    public function detectEmailByBody(PlancakeEmailParser $parser)
    {
        if ($this->http->XPath->query("//text()[contains(normalize-space(), 'You have been sent this email by the Trainline Group.')]")->length > 0) {
            return false;
        }

        $pdfs = $parser->searchAttachmentByName($this->pdfPattern);

        foreach ($pdfs as $pdf) {
            $textPdf = \PDF::convertToText($parser->getAttachmentBody($pdf));

            if (empty($textPdf)) {
                continue;
            }

            if (stripos($textPdf, $this->reBody) === false) {
                continue;
            }

            foreach ($this->reBody2 as $re) {
                if (strpos($textPdf, $re) !== false) {
                    return true;
                }
            }
        }

        return false;
    }

    public function ParsePlanEmailExternal(PlancakeEmailParser $parser, Email $email)
    {
        $this->date = strtotime($parser->getHeader('date'));

        $this->http->FilterHTML = false;

        $pdfs = $parser->searchAttachmentByName($this->pdfPattern);

        foreach ($pdfs as $pdf) {
            $textPdf = \PDF::convertToText($parser->getAttachmentBody($pdf));

            if (empty($textPdf)) {
                continue;
            }

            foreach ($this->reBody2 as $lang => $re) {
                if (strpos($textPdf, $re) !== false) {
                    $this->lang = $lang;
                    $this->parsePdf($email, $textPdf);

                    break;
                }
            }
        }

        $class = explode('\\', __CLASS__);
        $email->setType(end($class) . ucfirst($this->lang));

        return $email;
    }

    public static function getEmailLanguages()
    {
        return array_keys(self::$dictionary);
    }

    public static function getEmailTypesCount()
    {
        return count(self::$dictionary);
    }

    private function parsePdf(Email $email, $textPdf): void
    {
        $tickets = $this->splitText($textPdf, "#^[ ]*{$this->opt($this->t("pageHeader"))}(?:[ ]{2}|$)#im");

        foreach ($tickets as $tText) {
            $this->parseTicket($email, $tText);
        }
    }

    private function parseTicket(Email $email, $text): void
    {
//        $this->logger->debug('$text = '.print_r( $text,true));

        $t = $email->add()->train();

        // for google, to help find correct address of stations
        if (stripos($text, 'www.raileurope.com') !== false
            || stripos($text, 'Thank you for booking with Rail Europe') !== false
            || stripos($text, 'On French train stations:') !== false
        ) {
            $region = $this->t("europe");
        } else {
            $region = '';
        }

        // RecordLocator
        if (preg_match("#(?:\n *| {3,})({$this->opt($this->t("DOSSIER VOYAGE"))}) *:? *([\w\-]{5,})\n#i", $text, $m)) {
            $t->addConfirmationNumber($m[2], rtrim($m[1], ': '));
        }

        // Passengers
        if (preg_match_all("/{$this->opt($this->t("Nom"))}\s*:\s*(.*?)\s{2,}/", $text, $surnameMatches)) {
            $surnames = $surnameMatches[1];
        }

        if (preg_match_all("/{$this->opt($this->t("Prénom"))}\s*:\s*(.*?)\s{2,}/", $text, $nameMatches)) {
            $names = $nameMatches[1];
        }

        if (!empty($names) && !empty($surnames) && count($names) == count($surnames)) {
            foreach ($names as $key => $value) {
                $paxs[] = $value . ' ' . $surnames[$key];
            }
            $paxs = array_filter(array_unique($paxs));

            foreach ($paxs as $pax) {
                $t->addTraveller($pax);
            }
        } elseif (preg_match("/\n {0,10}{$this->opt($this->t("Bonjour"))} ([[:alpha:]]+(?: [[:alpha:]\-]+){1,4}),\n/u", $text, $m)) {
            $t->addTraveller($m[1]);
        }

        // TicketNumbers
        if (preg_match_all("/{$this->opt($this->t("N° e-billet"))}\s*:\s*(.+)/", $text, $ticketMatches)) {
            foreach (array_unique($ticketMatches[1]) as $tn) {
                $t->addTicketNumber($tn, false);
            }
        }

        // AccountNumbers
        if (preg_match_all("/(?:^|\s+){$this->opt($this->t("cardNumber"))}[ ]?:?[ ]*(\d[\d ]{6,}\d)$/m", $text, $accountMatches)) {
            foreach (array_unique($accountMatches[1]) as $an) {
                $t->addAccountNumber($an, false);
            }
        }

        // Currency
        if (preg_match_all("/(\d[\d\.\,]+)\s+([A-Z]{3})\s.*?{$this->opt($this->t("Nom"))}/s", $text, $priceMatches)
            && count(array_unique($priceMatches[2])) === 1
        ) {
            $t->price()
                ->total(array_sum($priceMatches[1]))
                ->currency(array_shift($priceMatches[2]));
        } elseif (preg_match("/\n *{$this->opt($this->t("Montant du voyage"))} +(\d[\d\.\, ]+)\s+([A-Z]{3})\n/", $text, $m)
        ) {
            $t->price()
                ->total(PriceHelper::parse($m[1], $m[2]))
                ->currency($m[2]);
        }

        if (preg_match_all("#^[ ]*{$this->opt($this->t("Départ / Arrivée"))}.+$((?:\n+.+){1,30}?)\n\s*(?:\w+ ){0,2}{$this->opt($this->t("endSegment"))}#mu", $text, $segments)) {
            foreach ($segments[1] as $i => $stext) {
                $pos = $this->TableHeadPos($this->inOneRow($stext));
                $table = $this->splitCols($stext, $pos);

                if (count($table) < 3) {
                    $this->logger->debug("incorrect parse table ({$i})");

                    return;
                }

                $names = array_merge([], array_filter(explode("\n", $table[0])));

                if (count($names) != 2) {
                    $this->logger->debug("incorrect names count ({$i})");

                    return;
                }
                $dates = array_merge([], array_filter(explode("\n", $table[1])));

                if (count($dates) != 2) {
                    $this->logger->debug("incorrect dates count ({$i})");

                    return;
                }

                $s = $t->addSegment();

                $number = $this->re("#" . $this->opt($this->t("TRAIN N°")) . "\s*(\d+)#", $table[2]);

                if (empty($number)) {
                    $nt = $this->re("#^.* +" . $this->opt($this->t("Date / Heure")) . " {2,}(.+?)( {2,}|\n)#", $segments[0][$i]);

                    if (preg_match("/^\s*[[:alpha:]][[:alpha:]\W]+ (\d{1,5})\s*$/", $nt, $m)) {
                        $number = $m[1];
                    }
                }
                $s->extra()
                    ->number($number);

                $s->departure()
                    ->name($names[0])
                    ->date(strtotime($this->normalizeDate($dates[0])));

                $s->arrival()
                    ->name($names[1])
                    ->date(strtotime($this->normalizeDate($dates[1])));

                if ($region) {
                    $s->departure()->geoTip($region);
                    $s->arrival()->geoTip($region);
                }

                $s->extra()
                    ->cabin($this->re("#(.*? {$this->opt($this->t("CLASSE"))})#", $table[2]), true, true);

                // Seats
                $seat = $this->re("#(?:PLACE|SEAT|PLATZ)\s+(\d+)\b#", $table[2]);

                if ($seat !== null) {
                    $s->extra()->seat($seat);
                }
                $s->extra()->car($this->re("#(?:VOITURE|COACH|WAGEN)\s+(\d+)\b#", $table[2]), false, true);
            }
        }
    }

    private function t($word)
    {
        if (!isset(self::$dictionary[$this->lang]) || !isset(self::$dictionary[$this->lang][$word])) {
            return $word;
        }

        return self::$dictionary[$this->lang][$word];
    }

    private function normalizeDate($str)
    {
        $year = date("Y", $this->date);
        $in = [
            "#^(\d+)[/\.](\d+)\s+(?:à|at|um|om)\s+(\d+)(?:h|:)(\d+)$#", //12/09 à 07h20   |   04.09 um 06:52
        ];
        $out = [
            "$1.$2.$year, $3:$4",
        ];
        $str = preg_replace($in, $out, $str);

        if (preg_match("#\d+\s+([^\d\s]+)\s+\d{4}#", $str, $m)) {
            if ($en = MonthTranslate::translate($m[1], $this->lang)) {
                $str = str_replace($m[1], $en, $str);
            }
        }

        return $str;
    }

    private function re($re, $str, $c = 1)
    {
        preg_match($re, $str, $m);

        if (isset($m[$c])) {
            return $m[$c];
        }

        return null;
    }

    private function splitText(?string $textSource, string $pattern, bool $saveDelimiter = false): array
    {
        $result = [];

        if ($saveDelimiter) {
            $textFragments = preg_split($pattern, $textSource, -1, PREG_SPLIT_DELIM_CAPTURE);
            array_shift($textFragments);

            for ($i = 0; $i < count($textFragments) - 1; $i += 2) {
                $result[] = $textFragments[$i] . $textFragments[$i + 1];
            }
        } else {
            $result = preg_split($pattern, $textSource);
            array_shift($result);
        }

        return $result;
    }

    private function TableHeadPos($row)
    {
        $head = array_filter(array_map('trim', explode("|", preg_replace("#\s{2,}#", "|", $row))));
        $pos = [];
        $lastpos = 0;

        foreach ($head as $word) {
            $pos[] = mb_strpos($row, $word, $lastpos, 'UTF-8');
            $lastpos = mb_strpos($row, $word, $lastpos, 'UTF-8') + mb_strlen($word, 'UTF-8');
        }

        return $pos;
    }

    private function SplitCols($text, $pos = false)
    {
        $cols = [];
        $rows = explode("\n", $text);

        if (!$pos) {
            $pos = $this->TableHeadPos($rows[0]);
        }
        arsort($pos);

        foreach ($rows as $row) {
            foreach ($pos as $k=>$p) {
                $cols[$k][] = trim(mb_substr($row, $p, null, 'UTF-8'));
                $row = mb_substr($row, 0, $p, 'UTF-8');
            }
        }
        ksort($cols);

        foreach ($cols as &$col) {
            $col = implode("\n", $col);
        }

        return $cols;
    }

    private function opt($field)
    {
        $field = (array) $field;

        return '(?:' . implode("|", array_map(function ($s) {
            return str_replace(' ', '\s+', preg_quote($s));
        }, $field)) . ')';
    }

    private function inOneRow($text)
    {
        $textRows = explode("\n", $text);
        $length = [];

        foreach ($textRows as $key => $row) {
            $length[] = strlen($row);
        }
        $length = max($length);
        $oneRow = '';

        for ($l = 0; $l < $length; $l++) {
            $notspace = false;

            foreach ($textRows as $key => $row) {
                if (isset($row[$l]) && (trim($row[$l]) !== '')) {
                    $notspace = true;
                    $oneRow[$l] = $row[$l];
                }
            }

            if ($notspace == false) {
                $oneRow[$l] = ' ';
            }
        }

        return $oneRow;
    }
}
